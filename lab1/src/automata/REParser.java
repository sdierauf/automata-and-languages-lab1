package automata;

//----------------------------------------------------
// The following code was generated by CUP v0.10k TUM Edition 20050516
// Sat Jan 30 08:16:01 CET 2010
//----------------------------------------------------

import java.io.StringReader;
import java.lang.reflect.Field;
import java.util.Stack;

import automata.resyntax.*;

/** CUP v0.10k TUM Edition 20050516 generated parser.
  * @version Sat Jan 30 08:16:01 CET 2010
  */
public class REParser extends lr_parser {

  /** Default constructor. */
  public REParser() {super();}

  /** Constructor which sets the default scanner. */
  public REParser(Scanner s) {super(s);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\014\000\002\003\003\000\002\002\004\000\002\003" +
    "\005\000\002\004\003\000\002\004\004\000\002\005\003" +
    "\000\002\005\004\000\002\005\004\000\002\005\004\000" +
    "\002\006\003\000\002\006\003\000\002\006\005" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\021\000\010\005\012\011\010\013\011\001\002\000" +
    "\016\002\001\004\001\005\012\011\010\012\001\013\011" +
    "\001\002\000\024\002\ufffe\004\ufffe\005\ufffe\006\020\007" +
    "\021\010\022\011\ufffe\012\ufffe\013\ufffe\001\002\000\006" +
    "\002\023\004\014\001\002\000\024\002\ufffc\004\ufffc\005" +
    "\ufffc\006\ufffc\007\ufffc\010\ufffc\011\ufffc\012\ufffc\013\ufffc" +
    "\001\002\000\010\005\012\011\010\013\011\001\002\000" +
    "\024\002\ufff8\004\ufff8\005\ufff8\006\ufff8\007\ufff8\010\ufff8" +
    "\011\ufff8\012\ufff8\013\ufff8\001\002\000\024\002\ufff7\004" +
    "\ufff7\005\ufff7\006\ufff7\007\ufff7\010\ufff7\011\ufff7\012\ufff7" +
    "\013\ufff7\001\002\000\006\004\014\012\015\001\002\000" +
    "\010\005\012\011\010\013\011\001\002\000\024\002\ufff6" +
    "\004\ufff6\005\ufff6\006\ufff6\007\ufff6\010\ufff6\011\ufff6\012" +
    "\ufff6\013\ufff6\001\002\000\016\002\uffff\004\uffff\005\012" +
    "\011\010\012\uffff\013\011\001\002\000\024\002\ufffd\004" +
    "\ufffd\005\ufffd\006\020\007\021\010\022\011\ufffd\012\ufffd" +
    "\013\ufffd\001\002\000\024\002\ufffb\004\ufffb\005\ufffb\006" +
    "\ufffb\007\ufffb\010\ufffb\011\ufffb\012\ufffb\013\ufffb\001\002" +
    "\000\024\002\ufff9\004\ufff9\005\ufff9\006\ufff9\007\ufff9\010" +
    "\ufff9\011\ufff9\012\ufff9\013\ufff9\001\002\000\024\002\ufffa" +
    "\004\ufffa\005\ufffa\006\ufffa\007\ufffa\010\ufffa\011\ufffa\012" +
    "\ufffa\013\ufffa\001\002\000\004\002\000\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\021\000\012\003\005\004\003\005\004\006\006\001" +
    "\001\000\006\005\016\006\006\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\003\012\004" +
    "\003\005\004\006\006\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\004\015\005\004\006" +
    "\006\001\001\000\002\001\001\000\006\005\016\006\006" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$REParser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$REParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  @SuppressWarnings("unchecked")
public Symbol do_action(
    int                        act_num,
    lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$REParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



    @SuppressWarnings("all")
    
    public static RegExp parse(String f) throws Exception {
        return (RegExp) (new REParser(new RETokenizer(new StringReader(f))).parse().value);
    }
    
    public static String getConstantName(int value) {
        for (Field f : sym.class.getFields())
            try {
                if (f.getInt(null) == value)
                    return f.getName();
            } catch (Exception e) {
            }
        return "unknown";
    }
    public void report_error(String msg, Object info) {
        String errMsg = "Error: " + msg;
        Symbol s = null;
        if (info instanceof Symbol)
            s = (Symbol) info;
        if (s != null)
            errMsg += " (sym: "+getConstantName(s.sym)+" value: " + s.value + ")";
        System.err.println(errMsg);
    }
    public void report_fatal_error(String msg, Object info) {
        report_error(msg, info);
        System.exit(-1);
    }

}

/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings("unused")
class CUP$REParser$actions {
  private final REParser parser;

  /** Constructor */
  CUP$REParser$actions(REParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  @SuppressWarnings("unchecked")
public final Symbol CUP$REParser$do_action(
    int                        CUP$REParser$act_num,
    lr_parser CUP$REParser$parser,
    java.util.Stack            CUP$REParser$stack,
    int                        CUP$REParser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      Symbol CUP$REParser$result;

      /* select the action based on the action number */
      switch (CUP$REParser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // Primary ::= LPAR RegExp RPAR 
            {
              RegExp RESULT = null;
		int rleft = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).left;
		int rright = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).right;
		RegExp r = (RegExp)((Symbol) CUP$REParser$stack.elementAt(CUP$REParser$top-1)).value;
		 RESULT = r; 
              CUP$REParser$result = new Symbol(4/*Primary*/, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-2)).left, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right, RESULT);
            }
          return CUP$REParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // Primary ::= DOT 
            {
              RegExp RESULT = null;
		 RESULT = new Dot(); 
              CUP$REParser$result = new Symbol(4/*Primary*/, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).left, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right, RESULT);
            }
          return CUP$REParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // Primary ::= SYMBOL 
            {
              RegExp RESULT = null;
		int cleft = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).left;
		int cright = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right;
		Character c = (Character)((Symbol) CUP$REParser$stack.elementAt(CUP$REParser$top-0)).value;
		 RESULT = new Litteral(c); 
              CUP$REParser$result = new Symbol(4/*Primary*/, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).left, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right, RESULT);
            }
          return CUP$REParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // Factor ::= Factor ONEORMORE 
            {
              RegExp RESULT = null;
		int fleft = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).left;
		int fright = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).right;
		RegExp f = (RegExp)((Symbol) CUP$REParser$stack.elementAt(CUP$REParser$top-1)).value;
		 RESULT = new OneOrMore(f); 
              CUP$REParser$result = new Symbol(3/*Factor*/, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).left, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right, RESULT);
            }
          return CUP$REParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // Factor ::= Factor ZEROORONE 
            {
              RegExp RESULT = null;
		int fleft = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).left;
		int fright = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).right;
		RegExp f = (RegExp)((Symbol) CUP$REParser$stack.elementAt(CUP$REParser$top-1)).value;
		 RESULT = new ZeroOrOne(f); 
              CUP$REParser$result = new Symbol(3/*Factor*/, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).left, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right, RESULT);
            }
          return CUP$REParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // Factor ::= Factor CLEENE 
            {
              RegExp RESULT = null;
		int fleft = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).left;
		int fright = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).right;
		RegExp f = (RegExp)((Symbol) CUP$REParser$stack.elementAt(CUP$REParser$top-1)).value;
		 RESULT = new Closure(f); 
              CUP$REParser$result = new Symbol(3/*Factor*/, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).left, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right, RESULT);
            }
          return CUP$REParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // Factor ::= Primary 
            {
              RegExp RESULT = null;
		int pleft = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).left;
		int pright = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right;
		RegExp p = (RegExp)((Symbol) CUP$REParser$stack.elementAt(CUP$REParser$top-0)).value;
		 RESULT = p; 
              CUP$REParser$result = new Symbol(3/*Factor*/, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).left, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right, RESULT);
            }
          return CUP$REParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // Term ::= Term Factor 
            {
              RegExp RESULT = null;
		int tleft = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).left;
		int tright = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).right;
		RegExp t = (RegExp)((Symbol) CUP$REParser$stack.elementAt(CUP$REParser$top-1)).value;
		int fleft = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).left;
		int fright = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right;
		RegExp f = (RegExp)((Symbol) CUP$REParser$stack.elementAt(CUP$REParser$top-0)).value;
		 RESULT = new Concatenation(t, f); 
              CUP$REParser$result = new Symbol(2/*Term*/, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).left, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right, RESULT);
            }
          return CUP$REParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // Term ::= Factor 
            {
              RegExp RESULT = null;
		int fleft = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).left;
		int fright = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right;
		RegExp f = (RegExp)((Symbol) CUP$REParser$stack.elementAt(CUP$REParser$top-0)).value;
		 RESULT = f; 
              CUP$REParser$result = new Symbol(2/*Term*/, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).left, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right, RESULT);
            }
          return CUP$REParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // RegExp ::= RegExp UNION Term 
            {
              RegExp RESULT = null;
		int rleft = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-2)).left;
		int rright = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-2)).right;
		RegExp r = (RegExp)((Symbol) CUP$REParser$stack.elementAt(CUP$REParser$top-2)).value;
		int tleft = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).left;
		int tright = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right;
		RegExp t = (RegExp)((Symbol) CUP$REParser$stack.elementAt(CUP$REParser$top-0)).value;
		 RESULT = new Union(r, t); 
              CUP$REParser$result = new Symbol(1/*RegExp*/, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-2)).left, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right, RESULT);
            }
          return CUP$REParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= RegExp EOF 
            {
              Object RESULT = null;
		int start_valleft = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).left;
		int start_valright = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).right;
		RegExp start_val = (RegExp)((Symbol) CUP$REParser$stack.elementAt(CUP$REParser$top-1)).value;
		RESULT = start_val;
              CUP$REParser$result = new Symbol(0/*$START*/, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-1)).left, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right, RESULT);
            }
          /* ACCEPT */
          CUP$REParser$parser.done_parsing();
          return CUP$REParser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // RegExp ::= Term 
            {
              RegExp RESULT = null;
		int tleft = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).left;
		int tright = ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right;
		RegExp t = (RegExp)((Symbol) CUP$REParser$stack.elementAt(CUP$REParser$top-0)).value;
		 RESULT = t; 
              CUP$REParser$result = new Symbol(1/*RegExp*/, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).left, ((Symbol)CUP$REParser$stack.elementAt(CUP$REParser$top-0)).right, RESULT);
            }
          return CUP$REParser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

/* The following code was generated by JFlex 1.4.1 on 1/30/10 8:16 AM */


@SuppressWarnings("all")


/**
 * This class is a scanner generated by 
 * <a href="http://www.jflex.de/">JFlex</a> 1.4.1
 * on 1/30/10 8:16 AM from the specification file
 * <tt>re.lex</tt>
 */
class RETokenizer implements Scanner {

  /** This character denotes the end of file */
  public static final int YYEOF = -1;

  /** initial size of the lookahead buffer */
  private static final int ZZ_BUFFERSIZE = 16384;

  /** lexical states */
  public static final int YYINITIAL = 0;

  /** 
   * Translates characters to character classes
   */
  private static final char [] ZZ_CMAP = {
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  9,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  6,  7,  3,  4,  0,  0,  2,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
  };

  /** 
   * Translates DFA states to action switch labels.
   */
  private static final int [] ZZ_ACTION = zzUnpackAction();

  private static final String ZZ_ACTION_PACKED_0 =
    "\1\0\1\1\1\2\1\3\1\4\1\5\1\6\1\7"+
    "\1\10\1\1\1\11\1\12\1\13\1\14\1\15";

  private static int [] zzUnpackAction() {
    int [] result = new int[15];
    int offset = 0;
    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAction(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }


  /** 
   * Translates a state to a row index in the transition table
   */
  private static final int [] ZZ_ROWMAP = zzUnpackRowMap();

  private static final String ZZ_ROWMAP_PACKED_0 =
    "\0\0\0\12\0\12\0\12\0\12\0\12\0\12\0\12"+
    "\0\12\0\24\0\12\0\12\0\12\0\12\0\12";

  private static int [] zzUnpackRowMap() {
    int [] result = new int[15];
    int offset = 0;
    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackRowMap(String packed, int offset, int [] result) {
    int i = 0;  /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int high = packed.charAt(i++) << 16;
      result[j++] = high | packed.charAt(i++);
    }
    return j;
  }

  /** 
   * The transition table of the DFA
   */
  private static final int [] ZZ_TRANS = zzUnpackTrans();

  private static final String ZZ_TRANS_PACKED_0 =
    "\1\2\1\3\1\4\1\5\1\6\1\7\1\10\1\11"+
    "\1\12\14\0\1\13\1\0\1\14\1\15\1\0\1\16"+
    "\1\17\2\0";

  private static int [] zzUnpackTrans() {
    int [] result = new int[30];
    int offset = 0;
    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackTrans(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      value--;
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }


  /* error codes */
  private static final int ZZ_UNKNOWN_ERROR = 0;
  private static final int ZZ_NO_MATCH = 1;
  private static final int ZZ_PUSHBACK_2BIG = 2;

  /* error messages for the codes above */
  private static final String ZZ_ERROR_MSG[] = {
    "Unkown internal scanner error",
    "Error: could not match input",
    "Error: pushback value was too large"
  };

  /**
   * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
  private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();

  private static final String ZZ_ATTRIBUTE_PACKED_0 =
    "\1\0\10\11\1\1\5\11";

  private static int [] zzUnpackAttribute() {
    int [] result = new int[15];
    int offset = 0;
    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAttribute(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }

  /** the input device */
  private java.io.Reader zzReader;

  /** the current state of the DFA */
  private int zzState;

  /** the current lexical state */
  private int zzLexicalState = YYINITIAL;

  /** this buffer contains the current text to be matched and is
      the source of the yytext() string */
  private char zzBuffer[] = new char[ZZ_BUFFERSIZE];

  /** the textposition at the last accepting state */
  private int zzMarkedPos;

  /** the textposition at the last state to be included in yytext */
  private int zzPushbackPos;

  /** the current text position in the buffer */
  private int zzCurrentPos;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private int zzStartRead;

  /** endRead marks the last character in the buffer, that has been read
      from input */
  private int zzEndRead;

  /** number of newlines encountered up to the start of the matched text */
  private int yyline;

  /** the number of characters up to the start of the matched text */
  private int yychar;

  /**
   * the number of characters from the last newline up to the start of the 
   * matched text
   */
  private int yycolumn;

  /** 
   * zzAtBOL == true <=> the scanner is currently at the beginning of a line
   */
  private boolean zzAtBOL = true;

  /** zzAtEOF == true <=> the scanner is at the EOF */
  private boolean zzAtEOF;

  /** denotes if the user-EOF-code has already been executed */
  private boolean zzEOFDone;

  /* user code: */
    private Symbol symbol(int type) {
        return new Symbol(type, yyline, yycolumn);
    }
    
    private Symbol symbol(int type, Object value) {
        return new Symbol(type, yyline, yycolumn, value);
    }


  /**
   * Creates a new scanner
   * There is also a java.io.InputStream version of this constructor.
   *
   * @param   in  the java.io.Reader to read input from.
   */
  RETokenizer(java.io.Reader in) {
    this.zzReader = in;
  }

  /**
   * Creates a new scanner.
   * There is also java.io.Reader version of this constructor.
   *
   * @param   in  the java.io.Inputstream to read input from.
   */
  RETokenizer(java.io.InputStream in) {
    this(new java.io.InputStreamReader(in));
  }


  /**
   * Refills the input buffer.
   *
   * @return      <code>false</code>, iff there was new input.
   * 
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  private boolean zzRefill() throws java.io.IOException {

    /* first: make room (if you can) */
    if (zzStartRead > 0) {
      System.arraycopy(zzBuffer, zzStartRead,
                       zzBuffer, 0,
                       zzEndRead-zzStartRead);

      /* translate stored positions */
      zzEndRead-= zzStartRead;
      zzCurrentPos-= zzStartRead;
      zzMarkedPos-= zzStartRead;
      zzPushbackPos-= zzStartRead;
      zzStartRead = 0;
    }

    /* is the buffer big enough? */
    if (zzCurrentPos >= zzBuffer.length) {
      /* if not: blow it up */
      char newBuffer[] = new char[zzCurrentPos*2];
      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
      zzBuffer = newBuffer;
    }

    /* finally: fill the buffer with new input */
    int numRead = zzReader.read(zzBuffer, zzEndRead,
                                            zzBuffer.length-zzEndRead);

    if (numRead < 0) {
      return true;
    }
    else {
      zzEndRead+= numRead;
      return false;
    }
  }

    
  /**
   * Closes the input stream.
   */
  public final void yyclose() throws java.io.IOException {
    zzAtEOF = true;            /* indicate end of file */
    zzEndRead = zzStartRead;  /* invalidate buffer    */

    if (zzReader != null)
      zzReader.close();
  }


  /**
   * Resets the scanner to read from a new input stream.
   * Does not close the old reader.
   *
   * All internal variables are reset, the old input stream 
   * <b>cannot</b> be reused (internal buffer is discarded and lost).
   * Lexical state is set to <tt>ZZ_INITIAL</tt>.
   *
   * @param reader   the new input stream 
   */
  public final void yyreset(java.io.Reader reader) {
    zzReader = reader;
    zzAtBOL  = true;
    zzAtEOF  = false;
    zzEndRead = zzStartRead = 0;
    zzCurrentPos = zzMarkedPos = zzPushbackPos = 0;
    yyline = yychar = yycolumn = 0;
    zzLexicalState = YYINITIAL;
  }


  /**
   * Returns the current lexical state.
   */
  public final int yystate() {
    return zzLexicalState;
  }


  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  public final void yybegin(int newState) {
    zzLexicalState = newState;
  }


  /**
   * Returns the text matched by the current regular expression.
   */
  public final String yytext() {
    return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
  }


  /**
   * Returns the character at position <tt>pos</tt> from the 
   * matched text. 
   * 
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch. 
   *            A value from 0 to yylength()-1.
   *
   * @return the character at position pos
   */
  public final char yycharat(int pos) {
    return zzBuffer[zzStartRead+pos];
  }


  /**
   * Returns the length of the matched text region.
   */
  public final int yylength() {
    return zzMarkedPos-zzStartRead;
  }


  /**
   * Reports an error that occured while scanning.
   *
   * In a wellformed scanner (no or only correct usage of 
   * yypushback(int) and a match-all fallback rule) this method 
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   *
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param   errorCode  the code of the errormessage to display
   */
  private void zzScanError(int errorCode) {
    String message;
    try {
      message = ZZ_ERROR_MSG[errorCode];
    }
    catch (ArrayIndexOutOfBoundsException e) {
      message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
    }

    throw new Error(message);
  } 


  /**
   * Pushes the specified amount of characters back into the input stream.
   *
   * They will be read again by then next call of the scanning method
   *
   * @param number  the number of characters to be read again.
   *                This number must not be greater than yylength()!
   */
  public void yypushback(int number)  {
    if ( number > yylength() )
      zzScanError(ZZ_PUSHBACK_2BIG);

    zzMarkedPos -= number;
  }


  /**
   * Contains user EOF-code, which will be executed exactly once,
   * when the end of file is reached
   */
  private void zzDoEOF() throws java.io.IOException {
    if (!zzEOFDone) {
      zzEOFDone = true;
      yyclose();
    }
  }


  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  public Symbol next_token() throws java.io.IOException {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    char [] zzBufferL = zzBuffer;
    char [] zzCMapL = ZZ_CMAP;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      boolean zzR = false;
      for (zzCurrentPosL = zzStartRead; zzCurrentPosL < zzMarkedPosL;
                                                             zzCurrentPosL++) {
        switch (zzBufferL[zzCurrentPosL]) {
        case '\u000B':
        case '\u000C':
        case '\u0085':
        case '\u2028':
        case '\u2029':
          yyline++;
          yycolumn = 0;
          zzR = false;
          break;
        case '\r':
          yyline++;
          yycolumn = 0;
          zzR = true;
          break;
        case '\n':
          if (zzR)
            zzR = false;
          else {
            yyline++;
            yycolumn = 0;
          }
          break;
        default:
          zzR = false;
          yycolumn++;
        }
      }

      if (zzR) {
        // peek one character ahead if it is \n (if we have counted one line too much)
        boolean zzPeek;
        if (zzMarkedPosL < zzEndReadL)
          zzPeek = zzBufferL[zzMarkedPosL] == '\n';
        else if (zzAtEOF)
          zzPeek = false;
        else {
          boolean eof = zzRefill();
          zzEndReadL = zzEndRead;
          zzMarkedPosL = zzMarkedPos;
          zzBufferL = zzBuffer;
          if (eof) 
            zzPeek = false;
          else 
            zzPeek = zzBufferL[zzMarkedPosL] == '\n';
        }
        if (zzPeek) yyline--;
      }
      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
  
      zzState = zzLexicalState;


      zzForAction: {
        while (true) {
    
          if (zzCurrentPosL < zzEndReadL)
            zzInput = zzBufferL[zzCurrentPosL++];
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = zzBufferL[zzCurrentPosL++];
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          int zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
        case 6: 
          { return symbol(sym.ZEROORONE);
          }
        case 14: break;
        case 8: 
          { return symbol(sym.RPAR);
          }
        case 15: break;
        case 12: 
          { return symbol(sym.SYMBOL, '(');
          }
        case 16: break;
        case 1: 
          { return symbol(sym.SYMBOL, yytext().charAt(0));
          }
        case 17: break;
        case 9: 
          { return symbol(sym.SYMBOL, '|');
          }
        case 18: break;
        case 7: 
          { return symbol(sym.LPAR);
          }
        case 19: break;
        case 3: 
          { return symbol(sym.DOT);
          }
        case 20: break;
        case 11: 
          { return symbol(sym.SYMBOL, '+');
          }
        case 21: break;
        case 10: 
          { return symbol(sym.SYMBOL, '*');
          }
        case 22: break;
        case 4: 
          { return symbol(sym.CLEENE);
          }
        case 23: break;
        case 2: 
          { return symbol(sym.UNION);
          }
        case 24: break;
        case 13: 
          { return symbol(sym.SYMBOL, ')');
          }
        case 25: break;
        case 5: 
          { return symbol(sym.ONEORMORE);
          }
        case 26: break;
        default: 
          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
            zzAtEOF = true;
            zzDoEOF();
              { return new Symbol(sym.EOF); }
          } 
          else {
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }


}

//----------------------------------------------------
// The following code was generated by CUP v0.10k TUM Edition 20050516
// Sat Jan 30 08:16:01 CET 2010
//----------------------------------------------------

/** CUP generated class containing symbol constants. */
class sym {
  /* terminals */
  public static final int ZEROORONE = 6;
  public static final int SYMBOL = 9;
  public static final int UNION = 2;
  public static final int ONEORMORE = 5;
  public static final int LPAR = 7;
  public static final int EOF = 0;
  public static final int DOT = 3;
  public static final int CLEENE = 4;
  public static final int error = 1;
  public static final int RPAR = 8;
}




@SuppressWarnings("unchecked")
abstract class lr_parser {
    /*-----------------------------------------------------------*/
    /*--- Constructor(s) ----------------------------------------*/
    /*-----------------------------------------------------------*/

    /** 
     * Simple constructor. 
     */
    public lr_parser() {
        symbolFactory = new DefaultSymbolFactory();
    }
    
    /** 
     * Constructor that sets the default scanner. [CSA/davidm] 
     */
    public lr_parser(Scanner s) {
        this(s,new DefaultSymbolFactory()); // TUM 20060327 old cup v10 Symbols as default
    }
    /** 
     * Constructor that sets the default scanner and a SymbolFactory
     */
    public lr_parser(Scanner s, SymbolFactory symfac) {
        this(); // in case default constructor someday does something
        symbolFactory = symfac;
        setScanner(s);
    }
    public SymbolFactory symbolFactory;// = new DefaultSymbolFactory();
    /**
     * Whenever creation of a new Symbol is necessary, one should use this factory.
     */
    public SymbolFactory getSymbolFactory(){
        return symbolFactory;
    }
  /*-----------------------------------------------------------*/
  /*--- (Access to) Static (Class) Variables ------------------*/
  /*-----------------------------------------------------------*/

  /** The default number of Symbols after an error we much match to consider 
   *  it recovered from. 
   */
  protected final static int _error_sync_size = 3;

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** The number of Symbols after an error we much match to consider it 
   *  recovered from. 
   */
  protected int error_sync_size() {return _error_sync_size; }

  /*-----------------------------------------------------------*/
  /*--- (Access to) Instance Variables ------------------------*/
  /*-----------------------------------------------------------*/

  /** Table of production information (supplied by generated subclass).
   *  This table contains one entry per production and is indexed by 
   *  the negative-encoded values (reduce actions) in the action_table.  
   *  Each entry has two parts, the index of the non-terminal on the 
   *  left hand side of the production, and the number of Symbols 
   *  on the right hand side. 
   */
  public abstract short[][] production_table();

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** The action table (supplied by generated subclass).  This table is
   *  indexed by state and terminal number indicating what action is to
   *  be taken when the parser is in the given state (i.e., the given state 
   *  is on top of the stack) and the given terminal is next on the input.  
   *  States are indexed using the first dimension, however, the entries for 
   *  a given state are compacted and stored in adjacent index, value pairs 
   *  which are searched for rather than accessed directly (see get_action()).  
   *  The actions stored in the table will be either shifts, reduces, or 
   *  errors.  Shifts are encoded as positive values (one greater than the 
   *  state shifted to).  Reduces are encoded as negative values (one less 
   *  than the production reduced by).  Error entries are denoted by zero. 
   * 
   * @see automata.lr_parser#get_action
   */
  public abstract short[][] action_table();

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** The reduce-goto table (supplied by generated subclass).  This
   *  table is indexed by state and non-terminal number and contains
   *  state numbers.  States are indexed using the first dimension, however,
   *  the entries for a given state are compacted and stored in adjacent
   *  index, value pairs which are searched for rather than accessed 
   *  directly (see get_reduce()).  When a reduce occurs, the handle 
   *  (corresponding to the RHS of the matched production) is popped off 
   *  the stack.  The new top of stack indicates a state.  This table is 
   *  then indexed by that state and the LHS of the reducing production to 
   *  indicate where to "shift" to. 
   *
   * @see automata.lr_parser#get_reduce
   */
  public abstract short[][] reduce_table();

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** The index of the start state (supplied by generated subclass). */
  public abstract int start_state();

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** The index of the start production (supplied by generated subclass). */
  public abstract int start_production();

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** The index of the end of file terminal Symbol (supplied by generated 
   *  subclass). 
   */
  public abstract int EOF_sym();

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** The index of the special error Symbol (supplied by generated subclass). */
  public abstract int error_sym();

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Internal flag to indicate when parser should quit. */
  protected boolean _done_parsing = false;

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** This method is called to indicate that the parser should quit.  This is 
   *  normally called by an accept action, but can be used to cancel parsing 
   *  early in other circumstances if desired. 
   */
  public void done_parsing()
    {
      _done_parsing = true;
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
  /* Global parse state shared by parse(), error recovery, and 
   * debugging routines */
  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Indication of the index for top of stack (for use by actions). */
  protected int tos;

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** The current lookahead Symbol. */
  protected Symbol cur_token;

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** The parse stack itself. */
  protected Stack stack = new Stack();

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Direct reference to the production table. */ 
  protected short[][] production_tab;

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Direct reference to the action table. */
  protected short[][] action_tab;

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Direct reference to the reduce-goto table. */
  protected short[][] reduce_tab;

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** This is the scanner object used by the default implementation
   *  of scan() to get Symbols.  To avoid name conflicts with existing
   *  code, this field is private. [CSA/davidm] */
  private Scanner _scanner;

  /**
   * Simple accessor method to set the default scanner.
   */
  public void setScanner(Scanner s) { _scanner = s; }

  /**
   * Simple accessor method to get the default scanner.
   */
  public Scanner getScanner() { return _scanner; }

  /*-----------------------------------------------------------*/
  /*--- General Methods ---------------------------------------*/
  /*-----------------------------------------------------------*/

  /** Perform a bit of user supplied action code (supplied by generated 
   *  subclass).  Actions are indexed by an internal action number assigned
   *  at parser generation time.
   *
   * @param act_num   the internal index of the action to be performed.
   * @param parser    the parser object we are acting for.
   * @param stack     the parse stack of that object.
   * @param top       the index of the top element of the parse stack.
   */
  public abstract Symbol do_action(
    int       act_num, 
    lr_parser parser, 
    Stack     stack, 
    int       top) 
    throws java.lang.Exception;

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** User code for initialization inside the parser.  Typically this 
   *  initializes the scanner.  This is called before the parser requests
   *  the first Symbol.  Here this is just a placeholder for subclasses that 
   *  might need this and we perform no action.   This method is normally
   *  overridden by the generated code using this contents of the "init with"
   *  clause as its body.
   */
  public void user_init() throws java.lang.Exception { }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Initialize the action object.  This is called before the parser does
   *  any parse actions. This is filled in by generated code to create
   *  an object that encapsulates all action code. 
   */ 
  protected abstract void init_actions() throws java.lang.Exception;

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Get the next Symbol from the input (supplied by generated subclass).
   *  Once end of file has been reached, all subsequent calls to scan 
   *  should return an EOF Symbol (which is Symbol number 0).  By default
   *  this method returns getScanner().next_token(); this implementation
   *  can be overriden by the generated parser using the code declared in
   *  the "scan with" clause.  Do not recycle objects; every call to
   *  scan() should return a fresh object.
   */
  public Symbol scan() throws java.lang.Exception {
    Symbol sym = getScanner().next_token();
    return (sym!=null) ? sym : getSymbolFactory().newSymbol("END_OF_FILE",EOF_sym());
  }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Report a fatal error.  This method takes a  message string and an 
   *  additional object (to be used by specializations implemented in 
   *  subclasses).  Here in the base class a very simple implementation 
   *  is provided which reports the error then throws an exception. 
   *
   * @param message an error message.
   * @param info    an extra object reserved for use by specialized subclasses.
   */
  public void report_fatal_error(
    String   message, 
    Object   info)
    throws java.lang.Exception
    {
      /* stop parsing (not really necessary since we throw an exception, but) */
      done_parsing();

      /* use the normal error message reporting to put out the message */
      report_error(message, info);

      /* throw an exception */
      throw new Exception("Can't recover from previous error(s)");
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Report a non fatal error (or warning).  This method takes a message 
   *  string and an additional object (to be used by specializations 
   *  implemented in subclasses).  Here in the base class a very simple 
   *  implementation is provided which simply prints the message to 
   *  System.err. 
   *
   * @param message an error message.
   * @param info    an extra object reserved for use by specialized subclasses.
   */
  public void report_error(String message, Object info)
    {
      System.err.print(message);
      System.err.flush();
      if (info instanceof Symbol)
        if (((Symbol)info).left != -1)
        System.err.println(" at character " + ((Symbol)info).left + 
                           " of input");
        else System.err.println("");
      else System.err.println("");
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** This method is called when a syntax error has been detected and recovery 
   *  is about to be invoked.  Here in the base class we just emit a 
   *  "Syntax error" error message.  
   *
   * @param cur_token the current lookahead Symbol.
   */
  public void syntax_error(Symbol cur_token)
    {
      report_error("Syntax error", cur_token);
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** This method is called if it is determined that syntax error recovery 
   *  has been unsuccessful.  Here in the base class we report a fatal error. 
   *
   * @param cur_token the current lookahead Symbol.
   */
  public void unrecovered_syntax_error(Symbol cur_token)
    throws java.lang.Exception
    {
      report_fatal_error("Couldn't repair and continue parse", cur_token);
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Fetch an action from the action table.  The table is broken up into
   *  rows, one per state (rows are indexed directly by state number).  
   *  Within each row, a list of index, value pairs are given (as sequential
   *  entries in the table), and the list is terminated by a default entry 
   *  (denoted with a Symbol index of -1).  To find the proper entry in a row 
   *  we do a linear or binary search (depending on the size of the row).  
   *
   * @param state the state index of the action being accessed.
   * @param sym   the Symbol index of the action being accessed.
   */
  protected final short get_action(int state, int sym)
    {
      short tag;
      int first, last, probe;
      short[] row = action_tab[state];

      /* linear search if we are < 10 entries */
      if (row.length < 20)
        for (probe = 0; probe < row.length; probe++)
          {
            /* is this entry labeled with our Symbol or the default? */
            tag = row[probe++];
            if (tag == sym || tag == -1)
              {
                /* return the next entry */
                return row[probe];
              }
          }
      /* otherwise binary search */
      else
        {
          first = 0; 
          last = (row.length-1)/2 - 1;  /* leave out trailing default entry */
          while (first <= last)
            {
              probe = (first+last)/2;
              if (sym == row[probe*2])
                return row[probe*2+1];
              else if (sym > row[probe*2])
                first = probe+1;
              else
                last = probe-1;
            }

          /* not found, use the default at the end */
          return row[row.length-1];
        }

      /* shouldn't happened, but if we run off the end we return the 
         default (error == 0) */
      return 0;
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Fetch a state from the reduce-goto table.  The table is broken up into
   *  rows, one per state (rows are indexed directly by state number).  
   *  Within each row, a list of index, value pairs are given (as sequential
   *  entries in the table), and the list is terminated by a default entry 
   *  (denoted with a Symbol index of -1).  To find the proper entry in a row 
   *  we do a linear search.  
   *
   * @param state the state index of the entry being accessed.
   * @param sym   the Symbol index of the entry being accessed.
   */
  protected final short get_reduce(int state, int sym)
    {
      short tag;
      short[] row = reduce_tab[state];

      /* if we have a null row we go with the default */
      if (row == null)
        return -1;

      for (int probe = 0; probe < row.length; probe++)
        {
          /* is this entry labeled with our Symbol or the default? */
          tag = row[probe++];
          if (tag == sym || tag == -1)
            {
              /* return the next entry */
              return row[probe];
            }
        }
      /* if we run off the end we return the default (error == -1) */
      return -1;
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** This method provides the main parsing routine.  It returns only when 
   *  done_parsing() has been called (typically because the parser has 
   *  accepted, or a fatal error has been reported).  See the header 
   *  documentation for the class regarding how shift/reduce parsers operate
   *  and how the various tables are used.
   */
  public Symbol parse() throws java.lang.Exception
    {
      /* the current action code */
      int act;

      /* the Symbol/stack element returned by a reduce */
      Symbol lhs_sym = null;

      /* information about production being reduced with */
      short handle_size, lhs_sym_num;

      /* set up direct reference to tables to drive the parser */

      production_tab = production_table();
      action_tab     = action_table();
      reduce_tab     = reduce_table();

      /* initialize the action encapsulation object */
      init_actions();

      /* do user initialization */
      user_init();

      /* get the first token */
      cur_token = scan(); 

      /* push dummy Symbol with start state to get us underway */
      stack.removeAllElements();
      stack.push(getSymbolFactory().startSymbol("START", 0, start_state()));
      tos = 0;

      /* continue until we are told to stop */
      for (_done_parsing = false; !_done_parsing; )
        {
          /* Check current token for freshness. */
          if (cur_token.used_by_parser)
            throw new Error("Symbol recycling detected (fix your scanner).");

          /* current state is always on the top of the stack */

          /* look up action out of the current state with the current input */
          act = get_action(((Symbol)stack.peek()).parse_state, cur_token.sym);

          /* decode the action -- > 0 encodes shift */
          if (act > 0)
            {
              /* shift to the encoded state by pushing it on the stack */
              cur_token.parse_state = act-1;
              cur_token.used_by_parser = true;
              stack.push(cur_token);
              tos++;

              /* advance to the next Symbol */
              cur_token = scan();
            }
          /* if its less than zero, then it encodes a reduce action */
          else if (act < 0)
            {
              /* perform the action for the reduce */
              lhs_sym = do_action((-act)-1, this, stack, tos);

              /* look up information about the production */
              lhs_sym_num = production_tab[(-act)-1][0];
              handle_size = production_tab[(-act)-1][1];

              /* pop the handle off the stack */
              for (int i = 0; i < handle_size; i++)
                {
                  stack.pop();
                  tos--;
                }
              
              /* look up the state to go to from the one popped back to */
              act = get_reduce(((Symbol)stack.peek()).parse_state, lhs_sym_num);

              /* shift to that state */
              lhs_sym.parse_state = act;
              lhs_sym.used_by_parser = true;
              stack.push(lhs_sym);
              tos++;
            }
          /* finally if the entry is zero, we have an error */
          else if (act == 0)
            {
              /* call user syntax error reporting routine */
              syntax_error(cur_token);

              /* try to error recover */
              if (!error_recovery(false))
                {
                  /* if that fails give up with a fatal syntax error */
                  unrecovered_syntax_error(cur_token);

                  /* just in case that wasn't fatal enough, end parse */
                  done_parsing();
                } else {
                  lhs_sym = (Symbol)stack.peek();
                }
            }
        }
      return lhs_sym;
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Write a debugging message to System.err for the debugging version 
   *  of the parser. 
   *
   * @param mess the text of the debugging message.
   */
  public void debug_message(String mess)
    {
      System.err.println(mess);
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Dump the parse stack for debugging purposes. */
  public void dump_stack()
    {
      if (stack == null)
        {
          debug_message("# Stack dump requested, but stack is null");
          return;
        }

      debug_message("============ Parse Stack Dump ============");

      /* dump the stack */
      for (int i=0; i<stack.size(); i++)
        {
          debug_message("Symbol: " + ((Symbol)stack.elementAt(i)).sym +
                        " State: " + ((Symbol)stack.elementAt(i)).parse_state);
        }
      debug_message("==========================================");
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Do debug output for a reduce. 
   *
   * @param prod_num  the production we are reducing with.
   * @param nt_num    the index of the LHS non terminal.
   * @param rhs_size  the size of the RHS.
   */
  public void debug_reduce(int prod_num, int nt_num, int rhs_size)
    {
      debug_message("# Reduce with prod #" + prod_num + " [NT=" + nt_num + 
                    ", " + "SZ=" + rhs_size + "]");
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Do debug output for shift. 
   *
   * @param shift_tkn the Symbol being shifted onto the stack.
   */
  public void debug_shift(Symbol shift_tkn)
    {
      debug_message("# Shift under term #" + shift_tkn.sym + 
                    " to state #" + shift_tkn.parse_state);
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Do debug output for stack state. [CSA]
   */
  public void debug_stack() {
      StringBuffer sb=new StringBuffer("## STACK:");
      for (int i=0; i<stack.size(); i++) {
          Symbol s = (Symbol) stack.elementAt(i);
          sb.append(" <state "+s.parse_state+", sym "+s.sym+">");
          if ((i%3)==2 || (i==(stack.size()-1))) {
              debug_message(sb.toString());
              sb = new StringBuffer("         ");
          }
      }
  }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Perform a parse with debugging output.  This does exactly the
   *  same things as parse(), except that it calls debug_shift() and
   *  debug_reduce() when shift and reduce moves are taken by the parser
   *  and produces various other debugging messages.  
   */
  public Symbol debug_parse()
    throws java.lang.Exception
    {
      /* the current action code */
      int act;

      /* the Symbol/stack element returned by a reduce */
      Symbol lhs_sym = null;

      /* information about production being reduced with */
      short handle_size, lhs_sym_num;

      /* set up direct reference to tables to drive the parser */
      production_tab = production_table();
      action_tab     = action_table();
      reduce_tab     = reduce_table();

      debug_message("# Initializing parser");

      /* initialize the action encapsulation object */
      init_actions();

      /* do user initialization */
      user_init();

      /* the current Symbol */
      cur_token = scan(); 

      debug_message("# Current Symbol is #" + cur_token.sym);

      /* push dummy Symbol with start state to get us underway */
      stack.removeAllElements();
      stack.push(getSymbolFactory().startSymbol("START",0, start_state()));
      tos = 0;

      /* continue until we are told to stop */
      for (_done_parsing = false; !_done_parsing; )
        {
          /* Check current token for freshness. */
          if (cur_token.used_by_parser)
            throw new Error("Symbol recycling detected (fix your scanner).");

          /* current state is always on the top of the stack */
          //debug_stack();

          /* look up action out of the current state with the current input */
          act = get_action(((Symbol)stack.peek()).parse_state, cur_token.sym);

          /* decode the action -- > 0 encodes shift */
          if (act > 0)
            {
              /* shift to the encoded state by pushing it on the stack */
              cur_token.parse_state = act-1;
              cur_token.used_by_parser = true;
              debug_shift(cur_token);
              stack.push(cur_token);
              tos++;

              /* advance to the next Symbol */
              cur_token = scan();
              debug_message("# Current token is " + cur_token);
            }
          /* if its less than zero, then it encodes a reduce action */
          else if (act < 0)
            {
              /* perform the action for the reduce */
              lhs_sym = do_action((-act)-1, this, stack, tos);

              /* look up information about the production */
              lhs_sym_num = production_tab[(-act)-1][0];
              handle_size = production_tab[(-act)-1][1];

              debug_reduce((-act)-1, lhs_sym_num, handle_size);

              /* pop the handle off the stack */
              for (int i = 0; i < handle_size; i++)
                {
                  stack.pop();
                  tos--;
                }
              
              /* look up the state to go to from the one popped back to */
              act = get_reduce(((Symbol)stack.peek()).parse_state, lhs_sym_num);
              debug_message("# Reduce rule: top state " +
                             ((Symbol)stack.peek()).parse_state +
                             ", lhs sym " + lhs_sym_num + " -> state " + act); 

              /* shift to that state */
              lhs_sym.parse_state = act;
              lhs_sym.used_by_parser = true;
              stack.push(lhs_sym);
              tos++;

              debug_message("# Goto state #" + act);
            }
          /* finally if the entry is zero, we have an error */
          else if (act == 0)
            {
              /* call user syntax error reporting routine */
              syntax_error(cur_token);

              /* try to error recover */
              if (!error_recovery(true))
                {
                  /* if that fails give up with a fatal syntax error */
                  unrecovered_syntax_error(cur_token);

                  /* just in case that wasn't fatal enough, end parse */
                  done_parsing();
                } else {
                  lhs_sym = (Symbol)stack.peek();
                }
            }
        }
      return lhs_sym;
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
  /* Error recovery code */
  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Attempt to recover from a syntax error.  This returns false if recovery 
   *  fails, true if it succeeds.  Recovery happens in 4 steps.  First we
   *  pop the parse stack down to a point at which we have a shift out
   *  of the top-most state on the error Symbol.  This represents the
   *  initial error recovery configuration.  If no such configuration is
   *  found, then we fail.  Next a small number of "lookahead" or "parse
   *  ahead" Symbols are read into a buffer.  The size of this buffer is 
   *  determined by error_sync_size() and determines how many Symbols beyond
   *  the error must be matched to consider the recovery a success.  Next, 
   *  we begin to discard Symbols in attempt to get past the point of error
   *  to a point where we can continue parsing.  After each Symbol, we attempt 
   *  to "parse ahead" though the buffered lookahead Symbols.  The "parse ahead"
   *  process simulates that actual parse, but does not modify the real 
   *  parser's configuration, nor execute any actions. If we can  parse all 
   *  the stored Symbols without error, then the recovery is considered a 
   *  success.  Once a successful recovery point is determined, we do an
   *  actual parse over the stored input -- modifying the real parse 
   *  configuration and executing all actions.  Finally, we return the the 
   *  normal parser to continue with the overall parse.
   *
   * @param debug should we produce debugging messages as we parse.
   */
  protected boolean error_recovery(boolean debug)
    throws java.lang.Exception
    {
      if (debug) debug_message("# Attempting error recovery");

      /* first pop the stack back into a state that can shift on error and 
         do that shift (if that fails, we fail) */
      if (!find_recovery_config(debug))
        {
          if (debug) debug_message("# Error recovery fails");
          return false;
        }

      /* read ahead to create lookahead we can parse multiple times */
      read_lookahead();

      /* repeatedly try to parse forward until we make it the required dist */
      for (;;)
        {
          /* try to parse forward, if it makes it, bail out of loop */
          if (debug) debug_message("# Trying to parse ahead");
          if (try_parse_ahead(debug))
            {
              break;
            }

          /* if we are now at EOF, we have failed */
          if (lookahead[0].sym == EOF_sym()) 
            {
              if (debug) debug_message("# Error recovery fails at EOF");
              return false;
            }

          /* otherwise, we consume another Symbol and try again */
          // BUG FIX by Bruce Hutton
          // Computer Science Department, University of Auckland,
          // Auckland, New Zealand.
          // It is the first token that is being consumed, not the one 
          // we were up to parsing
          if (debug) 
              debug_message("# Consuming Symbol #" + lookahead[ 0 ].sym);
          restart_lookahead();
        }

      /* we have consumed to a point where we can parse forward */
      if (debug) debug_message("# Parse-ahead ok, going back to normal parse");

      /* do the real parse (including actions) across the lookahead */
      parse_lookahead(debug);

      /* we have success */
      return true;
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Determine if we can shift under the special error Symbol out of the 
   *  state currently on the top of the (real) parse stack. 
   */
  protected boolean shift_under_error()
    {
      /* is there a shift under error Symbol */
      return get_action(((Symbol)stack.peek()).parse_state, error_sym()) > 0;
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Put the (real) parse stack into error recovery configuration by 
   *  popping the stack down to a state that can shift on the special 
   *  error Symbol, then doing the shift.  If no suitable state exists on 
   *  the stack we return false 
   *
   * @param debug should we produce debugging messages as we parse.
   */
  protected boolean find_recovery_config(boolean debug)
    {
      Symbol error_token;
      int act;

      if (debug) debug_message("# Finding recovery state on stack");

      /* Remember the right-position of the top symbol on the stack */
      Symbol right = ((Symbol)stack.peek());// TUM 20060327 removed .right      
      Symbol left  = right;// TUM 20060327 removed .left        

      /* pop down until we can shift under error Symbol */
      while (!shift_under_error())
        {
          /* pop the stack */
          if (debug) 
            debug_message("# Pop stack by one, state was # " +
                          ((Symbol)stack.peek()).parse_state);
          left = ((Symbol)stack.pop()); // TUM 20060327 removed .left   
          tos--;

          /* if we have hit bottom, we fail */
          if (stack.empty()) 
            {
              if (debug) debug_message("# No recovery state found on stack");
              return false;
            }
        }

      /* state on top of the stack can shift under error, find the shift */
      act = get_action(((Symbol)stack.peek()).parse_state, error_sym());
      if (debug) 
        {
          debug_message("# Recover state found (#" + 
                        ((Symbol)stack.peek()).parse_state + ")");
          debug_message("# Shifting on error to state #" + (act-1));
        }

      /* build and shift a special error Symbol */
      error_token = getSymbolFactory().newSymbol("ERROR",error_sym(), left, right);
      error_token.parse_state = act-1;
      error_token.used_by_parser = true;
      stack.push(error_token);
      tos++;

      return true;
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Lookahead Symbols used for attempting error recovery "parse aheads". */
  protected Symbol lookahead[];

  /** Position in lookahead input buffer used for "parse ahead". */
  protected int lookahead_pos;

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Read from input to establish our buffer of "parse ahead" lookahead 
   *  Symbols. 
   */
  protected void read_lookahead() throws java.lang.Exception
    {
      /* create the lookahead array */
      lookahead = new Symbol[error_sync_size()];

      /* fill in the array */
      for (int i = 0; i < error_sync_size(); i++)
        {
          lookahead[i] = cur_token;
          cur_token = scan();
        }

      /* start at the beginning */
      lookahead_pos = 0;
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Return the current lookahead in our error "parse ahead" buffer. */
  protected Symbol cur_err_token() { return lookahead[lookahead_pos]; }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Advance to next "parse ahead" input Symbol. Return true if we have 
   *  input to advance to, false otherwise. 
   */
  protected boolean advance_lookahead()
    {
      /* advance the input location */
      lookahead_pos++;

      /* return true if we didn't go off the end */
      return lookahead_pos < error_sync_size();
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Reset the parse ahead input to one Symbol past where we started error 
   *  recovery (this consumes one new Symbol from the real input). 
   */
  protected void restart_lookahead() throws java.lang.Exception
    {
      /* move all the existing input over */
      for (int i = 1; i < error_sync_size(); i++)
        lookahead[i-1] = lookahead[i];

      /* read a new Symbol into the last spot */
      // BUG Fix by Bruce Hutton
      // Computer Science Department, University of Auckland,
      // Auckland, New Zealand. [applied 5-sep-1999 by csa]
      // The following two lines were out of order!!
      lookahead[error_sync_size()-1] = cur_token;
      cur_token = scan();

      /* reset our internal position marker */
      lookahead_pos = 0;
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Do a simulated parse forward (a "parse ahead") from the current 
   *  stack configuration using stored lookahead input and a virtual parse
   *  stack.  Return true if we make it all the way through the stored 
   *  lookahead input without error. This basically simulates the action of 
   *  parse() using only our saved "parse ahead" input, and not executing any 
   *  actions.
   *
   * @param debug should we produce debugging messages as we parse.
   */
  protected boolean try_parse_ahead(boolean debug)
    throws java.lang.Exception
    {
      int act;
      short lhs, rhs_size;

      /* create a virtual stack from the real parse stack */
      virtual_parse_stack vstack = new virtual_parse_stack(stack);

      /* parse until we fail or get past the lookahead input */
      for (;;)
        {
          /* look up the action from the current state (on top of stack) */
          act = get_action(vstack.top(), cur_err_token().sym);

          /* if its an error, we fail */
          if (act == 0) return false;

          /* > 0 encodes a shift */
          if (act > 0)
            {
              /* push the new state on the stack */
              vstack.push(act-1);

              if (debug) debug_message("# Parse-ahead shifts Symbol #" + 
                       cur_err_token().sym + " into state #" + (act-1));

              /* advance simulated input, if we run off the end, we are done */
              if (!advance_lookahead()) return true;
            }
          /* < 0 encodes a reduce */
          else
            {
              /* if this is a reduce with the start production we are done */
              if ((-act)-1 == start_production()) 
                {
                  if (debug) debug_message("# Parse-ahead accepts");
                  return true;
                }

              /* get the lhs Symbol and the rhs size */
              lhs = production_tab[(-act)-1][0];
              rhs_size = production_tab[(-act)-1][1];

              /* pop handle off the stack */
              for (int i = 0; i < rhs_size; i++)
                vstack.pop();

              if (debug) 
                debug_message("# Parse-ahead reduces: handle size = " + 
                  rhs_size + " lhs = #" + lhs + " from state #" + vstack.top());

              /* look up goto and push it onto the stack */
              vstack.push(get_reduce(vstack.top(), lhs));
              if (debug) 
                debug_message("# Goto state #" + vstack.top());
            }
        }
    }

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** Parse forward using stored lookahead Symbols.  In this case we have
   *  already verified that parsing will make it through the stored lookahead
   *  Symbols and we are now getting back to the point at which we can hand
   *  control back to the normal parser.  Consequently, this version of the
   *  parser performs all actions and modifies the real parse configuration.  
   *  This returns once we have consumed all the stored input or we accept.
   *
   * @param debug should we produce debugging messages as we parse.
   */
  protected void parse_lookahead(boolean debug)
    throws java.lang.Exception
    {
      /* the current action code */
      int act;

      /* the Symbol/stack element returned by a reduce */
      Symbol lhs_sym = null;

      /* information about production being reduced with */
      short handle_size, lhs_sym_num;

      /* restart the saved input at the beginning */
      lookahead_pos = 0;

      if (debug) 
        {
          debug_message("# Reparsing saved input with actions");
          debug_message("# Current Symbol is #" + cur_err_token().sym);
          debug_message("# Current state is #" + 
                        ((Symbol)stack.peek()).parse_state);
        }

      /* continue until we accept or have read all lookahead input */
      while(!_done_parsing)
        {
          /* current state is always on the top of the stack */

          /* look up action out of the current state with the current input */
          act = 
            get_action(((Symbol)stack.peek()).parse_state, cur_err_token().sym);

          /* decode the action -- > 0 encodes shift */
          if (act > 0)
            {
              /* shift to the encoded state by pushing it on the stack */
              cur_err_token().parse_state = act-1;
              cur_err_token().used_by_parser = true;
              if (debug) debug_shift(cur_err_token());
              stack.push(cur_err_token());
              tos++;

              /* advance to the next Symbol, if there is none, we are done */
              if (!advance_lookahead()) 
                {
                  if (debug) debug_message("# Completed reparse");

                  /* scan next Symbol so we can continue parse */
                  // BUGFIX by Chris Harris <ckharris@ucsd.edu>:
                  //   correct a one-off error by commenting out
                  //   this next line.
                  /*cur_token = scan();*/

                  /* go back to normal parser */
                  return;
                }
              
              if (debug) 
                debug_message("# Current Symbol is #" + cur_err_token().sym);
            }
          /* if its less than zero, then it encodes a reduce action */
          else if (act < 0)
            {
              /* perform the action for the reduce */
              lhs_sym = do_action((-act)-1, this, stack, tos);

              /* look up information about the production */
              lhs_sym_num = production_tab[(-act)-1][0];
              handle_size = production_tab[(-act)-1][1];

              if (debug) debug_reduce((-act)-1, lhs_sym_num, handle_size);

              /* pop the handle off the stack */
              for (int i = 0; i < handle_size; i++)
                {
                  stack.pop();
                  tos--;
                }
              
              /* look up the state to go to from the one popped back to */
              act = get_reduce(((Symbol)stack.peek()).parse_state, lhs_sym_num);

              /* shift to that state */
              lhs_sym.parse_state = act;
              lhs_sym.used_by_parser = true;
              stack.push(lhs_sym);
              tos++;
               
              if (debug) debug_message("# Goto state #" + act);

            }
          /* finally if the entry is zero, we have an error 
             (shouldn't happen here, but...)*/
          else if (act == 0)
            {
              report_fatal_error("Syntax error", lhs_sym);
              return;
            }
        }

        
    }

  /*-----------------------------------------------------------*/

  /** Utility function: unpacks parse tables from strings */
  protected static short[][] unpackFromStrings(String[] sa)
    {
      // Concatanate initialization strings.
      StringBuffer sb = new StringBuffer(sa[0]);
      for (int i=1; i<sa.length; i++)
        sb.append(sa[i]);
      int n=0; // location in initialization string
      int size1 = (((int)sb.charAt(n))<<16) | ((int)sb.charAt(n+1)); n+=2;
      short[][] result = new short[size1][];
      for (int i=0; i<size1; i++) {
        int size2 = (((int)sb.charAt(n))<<16) | ((int)sb.charAt(n+1)); n+=2;
        result[i] = new short[size2];
        for (int j=0; j<size2; j++)
          result[i][j] = (short) (sb.charAt(n++)-2);
      }
      return result;
    }
}



class DefaultSymbolFactory implements SymbolFactory{
    // Factory methods
    /**
     * DefaultSymbolFactory for CUP.
     * Users are strongly encoraged to use ComplexSymbolFactory instead, since
     * it offers more detailed information about Symbols in source code.
     * Yet since migrating has always been a critical process, You have the
     * chance of still using the oldstyle Symbols.
     *
     * @deprecated as of CUP v11a
     * replaced by the new java_cup.runtime.ComplexSymbolFactory
     */
    //@deprecated 
    public DefaultSymbolFactory(){
    }
    public Symbol newSymbol(String name ,int id, Symbol left, Symbol right, Object value){
        return new Symbol(id,left,right,value);
    }
    public Symbol newSymbol(String name, int id, Symbol left, Symbol right){
        return new Symbol(id,left,right);
    }
    public Symbol newSymbol(String name, int id, int left, int right, Object value){
        return new Symbol(id,left,right,value);
    }
    public Symbol newSymbol(String name, int id, int left, int right){
        return new Symbol(id,left,right);
    }
    public Symbol startSymbol(String name, int id, int state){
        return new Symbol(id,state);
    }
    public Symbol newSymbol(String name, int id){
        return new Symbol(id);
    }
    public Symbol newSymbol(String name, int id, Object value){
        return new Symbol(id,value);
    }
}

class ComplexSymbolFactory implements SymbolFactory{
    public static class Location {
        private String unit="unknown";
        private int line, column;
        public Location(String unit, int line, int column){
            this.unit=unit;
            this.line=line;
            this.column=column;
        }
        public Location(int line, int column){
            this.line=line;
            this.column=column;
        }
        public String toString(){
            return unit+":"+line+"/"+column;
        }
        public int getColumn(){
            return column;
        }
        public int getLine(){
            return line;
        }
        public String getUnit(){
            return unit;
        }
    }
    /**
     * ComplexSymbol with detailed Location Informations and a Name
     */
    public static class ComplexSymbol extends Symbol {
        protected String name;
        protected Location xleft,xright;
        public ComplexSymbol(String name, int id) {
            super(id);
            this.name=name;
        }
        public ComplexSymbol(String name, int id, Object value) {
            super(id,value);
            this.name=name;
        }
        public String toString(){
            if (xleft==null || xright==null) return "Symbol: "+name;
            return "Symbol: "+name+" ("+xleft+" - "+xright+")";
        }
        public ComplexSymbol(String name, int id, int state) {
            super(id,state);
            this.name=name;
        }
        public ComplexSymbol(String name, int id, Symbol left, Symbol right) {
            super(id,left,right);
            this.name=name;
            if (left!=null)  this.xleft = ((ComplexSymbol)left).xleft;
            if (right!=null) this.xright= ((ComplexSymbol)right).xright;
        }
        public ComplexSymbol(String name, int id, Location left, Location right) {
            super(id);
            this.name=name;
            this.xleft=left;
            this.xright=right;
        }
        public ComplexSymbol(String name, int id, Symbol left, Symbol right, Object value) {
            super(id,value);
            this.name=name;
            if (left!=null)  this.xleft = ((ComplexSymbol)left).xleft;
            if (right!=null) this.xright= ((ComplexSymbol)right).xright;
        }
        public ComplexSymbol(String name, int id, Location left, Location right, Object value) {
            super(id,value);
            this.name=name;
            this.xleft=left;
            this.xright=right;
        }
        public Location getLeft(){
            return xleft;
        }
        public Location getRight(){
            return xright;
        }
    }


    // Factory methods
    public Symbol newSymbol(String name, int id, Location left, Location right, Object value){
        return new ComplexSymbol(name,id,left,right,value);
    }
    public Symbol newSymbol(String name, int id, Location left, Location right){
        return new ComplexSymbol(name,id,left,right);
    }
    public Symbol newSymbol(String name, int id, Symbol left, Symbol right, Object value){
        return new ComplexSymbol(name,id,left,right,value);
    }
    public Symbol newSymbol(String name, int id, Symbol left, Symbol right){
        return new ComplexSymbol(name,id,left,right);
    }
    public Symbol newSymbol(String name, int id){
        return new ComplexSymbol(name,id);
    }
    public Symbol newSymbol(String name, int id, Object value){
        return new ComplexSymbol(name,id,value);
    }
    public Symbol startSymbol(String name, int id, int state){
        return new ComplexSymbol(name,id,state);
    }
}


interface Scanner {
    /** Return the next token, or <code>null</code> on end-of-file. */
    public Symbol next_token() throws java.lang.Exception;
}

@SuppressWarnings("unchecked")
class virtual_parse_stack {
    /*-----------------------------------------------------------*/
    /*--- Constructor(s) ----------------------------------------*/
    /*-----------------------------------------------------------*/

    /** Constructor to build a virtual stack out of a real stack. */
    public virtual_parse_stack(Stack shadowing_stack) throws java.lang.Exception
      {
        /* sanity check */
        if (shadowing_stack == null)
          throw new Exception(
            "Internal parser error: attempt to create null virtual stack");

        /* set up our internals */
        real_stack = shadowing_stack;
        vstack     = new Stack();
        real_next  = 0;

        /* get one element onto the virtual portion of the stack */
        get_from_real();
      }

    /*-----------------------------------------------------------*/
    /*--- (Access to) Instance Variables ------------------------*/
    /*-----------------------------------------------------------*/
         
    /** The real stack that we shadow.  This is accessed when we move off
     *  the bottom of the virtual portion of the stack, but is always left
     *  unmodified.
     */
    protected Stack real_stack;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

    /** Top of stack indicator for where we leave off in the real stack.
     *  This is measured from top of stack, so 0 would indicate that no
     *  elements have been "moved" from the real to virtual stack. 
     */
    protected int real_next;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

    /** The virtual top portion of the stack.  This stack contains Integer
     *  objects with state numbers.  This stack shadows the top portion
     *  of the real stack within the area that has been modified (via operations
     *  on the virtual stack).  When this portion of the stack becomes empty we 
     *  transfer elements from the underlying stack onto this stack. 
     */
    protected Stack vstack;

    /*-----------------------------------------------------------*/
    /*--- General Methods ---------------------------------------*/
    /*-----------------------------------------------------------*/

    /** Transfer an element from the real to the virtual stack.  This assumes 
     *  that the virtual stack is currently empty.  
     */
    protected void get_from_real()
      {
        Symbol stack_sym;

        /* don't transfer if the real stack is empty */
        if (real_next >= real_stack.size()) return;

        /* get a copy of the first Symbol we have not transfered */
        stack_sym = (Symbol)real_stack.elementAt(real_stack.size()-1-real_next);

        /* record the transfer */
        real_next++;

        /* put the state number from the Symbol onto the virtual stack */
        vstack.push(new Integer(stack_sym.parse_state));
      }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

    /** Indicate whether the stack is empty. */
    public boolean empty()
      {
        /* if vstack is empty then we were unable to transfer onto it and 
           the whole thing is empty. */
        return vstack.empty();
      }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
        
    /** Return value on the top of the stack (without popping it). */
    public int top() throws java.lang.Exception
      {
        if (vstack.empty())
          throw new Exception(
                    "Internal parser error: top() called on empty virtual stack");

        return ((Integer)vstack.peek()).intValue();
      }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

    /** Pop the stack. */
    public void pop() throws java.lang.Exception
      {
        if (vstack.empty())
          throw new Exception(
                    "Internal parser error: pop from empty virtual stack");

        /* pop it */
        vstack.pop();

        /* if we are now empty transfer an element (if there is one) */
        if (vstack.empty())
          get_from_real();
      }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

    /** Push a state number onto the stack. */
    public void push(int state_num)
      {
        vstack.push(new Integer(state_num));
      }

    /*-----------------------------------------------------------*/

  }

interface SymbolFactory {
    // Factory methods
    /**
     * Construction with left/right propagation switched on
     */
    public Symbol newSymbol(String name, int id, Symbol left, Symbol right, Object value);
    public Symbol newSymbol(String name, int id, Symbol left, Symbol right);
    /**
     * Construction with left/right propagation switched off
     */
    public Symbol newSymbol(String name, int id, Object value);
    public Symbol newSymbol(String name, int id);
    /**
     * Construction of start symbol
     */
    public Symbol startSymbol(String name, int id, int state);
}


class Symbol {

//  TUM 20060327: Added new Constructor to provide more flexible way
//   for location handling
/*******************************
 *******************************/
    public Symbol(int id, Symbol left, Symbol right, Object o){
        this(id,left.left,right.right,o);
    }
    public Symbol(int id, Symbol left, Symbol right){
        this(id,left.left,right.right);
    }
/*******************************
  Constructor for l,r values
 *******************************/

  public Symbol(int id, int l, int r, Object o) {
    this(id);
    left = l;
    right = r;
    value = o;
  }

/*******************************
  Constructor for no l,r values
********************************/

  public Symbol(int id, Object o) {
    this(id, -1, -1, o);
  }

/*****************************
  Constructor for no value
  ***************************/

  public Symbol(int id, int l, int r) {
    this(id, l, r, null);
  }

/***********************************
  Constructor for no value or l,r
***********************************/

  public Symbol(int sym_num) {
    this(sym_num, -1);
    left = -1;
    right = -1;
  }

/***********************************
  Constructor to give a start state
***********************************/
  Symbol(int sym_num, int state)
    {
      sym = sym_num;
      parse_state = state;
    }

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** The symbol number of the terminal or non terminal being represented */
  public int sym;

  /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/

  /** The parse state to be recorded on the parse stack with this symbol.
   *  This field is for the convenience of the parser and shouldn't be 
   *  modified except by the parser. 
   */
  public int parse_state;
  /** This allows us to catch some errors caused by scanners recycling
   *  symbols.  For the use of the parser only. [CSA, 23-Jul-1999] */
  boolean used_by_parser = false;

/*******************************
  The data passed to parser
 *******************************/

  public int left, right;
  public Object value;

  /*****************************
    Printing this token out. (Override for pretty-print).
    ****************************/
  public String toString() { return "#"+sym; }
}






